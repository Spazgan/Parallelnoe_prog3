//#include <stdio.h>
//#include <omp.h>
//#include <locale.h>
//
//int main(int argc, char* argv[]) {
//    setlocale(LC_ALL, "Rus"); // Устанавливаем русскую локаль для корректного отображения текста
//
//    int n = 1;
//    printf("n в последовательной области (начало): %d\n", n);
//
//    // Параллельная область, где каждый поток получает свою копию переменной n
//#pragma omp parallel private(n)
//    {
//        printf("Значение n на нити (на входе): %d\n", n);
//        // Присваиваем переменной n номер текущего потока
//        n = omp_get_thread_num();
//        printf("Значение n на нити (на выходе): %d\n", n);
//    }
//
//    // После завершения параллельной области продолжаем в последовательной части программы
//    printf("n в последовательной области (конец): %d\n", n);
//
//    return 0;
//}

//#include <stdio.h>
//#include <omp.h>
//#include <locale.h>
//
//int main(int argc, char* argv[]) {
//    setlocale(LC_ALL, "Rus"); // Устанавливаем русскую локаль для корректного отображения текста
//    int i, m[10]; // Объявляем переменные: i и массив m из 10 элементов
//
//    printf("Массив m в начале:\n");
//    // Заполняем массив нулями и выводим его
//    for (i = 0; i < 10; i++) {
//        m[i] = 0; // Присваиваем каждому элементу массива значение 0
//        printf("%d\n", m[i]); // Выводим текущее значение элемента массива
//    }
//
//    // Параллельная область, где каждый поток изменяет один элемент массива
//#pragma omp parallel shared(m) // Директива OpenMP для параллельного выполнения
//    {
//        // Каждый поток изменяет элемент массива с индексом, равным его номеру
//        m[omp_get_thread_num()] = 1;
//    }
//
//    // Выводим массив после выполнения параллельной области
//    printf("Массив m в конце:\n");
//    for (i = 0; i < 10; i++) {
//        printf("%d\n", m[i]); // Выводим каждый элемент массива
//    }
//
//    return 0; // Завершаем программу
//}
//Пример 13 демонстрирует использование опции shared.Массив m объявлен общим для всех нитей.В начале последовательной области массив m заполняется нулями и выводится на печать.В параллельной области каждая
//нить находит элемент, номер которого совпадает с порядковым номером
//нити в общем массиве, и присваивает этому элементу значение 1
//#include <stdio.h>
//#include <omp.h>
//#include<locale.h>
//int main(int argc, char* argv[])
//{
//    setlocale(LC_ALL, "Rus");
//    int n = 1; // Инициализация переменной n значением 1
//    printf("Значение n в начале: %d\n", n); // Вывод начального значения переменной n
//
//    // Параллельная область с директивой firstprivate
//#pragma omp parallel firstprivate(n)
//    {
//        // Каждый поток выводит значение своей локальной копии переменной n
//        printf("Значение n на нити (на входе): %d\n", n);
//
//        // Присвоим локальной копии переменной n номер текущего потока
//        n = omp_get_thread_num(); // Получаем номер текущего потока и присваиваем его переменной n
//
//        // Выводим значение переменной n на выходе
//        printf("Значение n на нити (на выходе): %d\n", n);
//    }
//
//    // Выводим значение переменной n в конце программы
//    printf("Значение n в конце: %d\n", n);
//
//    return 0;
//}
//Пример 14 демонстрирует использование опции firstprivate.Переменная n объявлена как firstprivate в параллельной области.Значение n будет выведено в четырёх разных местах.Первый раз значение n будет выведено в последовательной области сразу после инициализации.Второй раз все
//нити выведут значение своей копии переменной n в начале параллельной области, и это значение будет равно 1. Далее, с помощью функции
//omp_get_thread_num() все нити присвоят переменной n свой порядковый номер и ещё раз выведут значение n.В последовательной области будет
//ещё раз выведено значение n, которое снова окажется равным 1.
//#include <stdio.h>
//#include <omp.h>
//#include<locale.h>
//int n;  // Глобальная переменная n
//#pragma omp threadprivate(n)  // Каждая нить будет иметь свою собственную копию переменной n
//
//int main(int argc, char* argv[]) {
//    setlocale(LC_ALL, "rus");
//    int num;  // Переменная для хранения номера текущей нити
//    n = 1;  // Инициализация переменной n в основной нити
//
//    // Первая параллельная область
//#pragma omp parallel private(num)
//    {
//        num = omp_get_thread_num();  // Получаем номер текущей нити
//        printf("Значение n на нити %d (на входе): %d\n", num, n);
//        // Присваиваем переменной n номер текущей нити
//        n = omp_get_thread_num();
//        printf("Значение n на нити %d (на выходе): %d\n", num, n);
//    }
//
//    // После выхода из параллельной области, основная нить выводит значение переменной n
//    printf("Значение n (середина): %d\n", n);
//
//    // Вторая параллельная область
//#pragma omp parallel private(num)
//    {
//        num = omp_get_thread_num();  // Получаем номер текущей нити
//        printf("Значение n на нити %d (ещё раз): %d\n", num, n);
//    }
//
//    return 0;
//}
//Пример 15 демонстрирует использование директивы threadprivate.Глобальная переменная n объявлена как threadprivate переменная.Значение
//переменной n выводится в четырёх разных местах.Первый раз все нити выведут значение своей копии переменной n в начале параллельной области, и
//это значение будет равно 1 на нити - мастере и 0 на остальных нитях.Далее с
//помощью функции omp_get_thread_num() все нити присвоят переменной n свой порядковый номер и выведут это значение.Затем в последовательной области будет ещё раз выведено значение переменной n, которое
//окажется равным порядковому номеру нити - мастера, то есть 0. В последний
//раз значение переменной n выводится в новой параллельной области, причём
//значение каждой локальной копии должно сохраниться.

#include <stdio.h>
#include<locale.h>
// Объявление глобальной переменной n
int n;
// Директива OpenMP, которая делает переменную n частной для каждой нити, т.е. каждой нити будет выделена своя отдельная копия переменной n.
#pragma omp threadprivate(n)

int main(int argc, char* argv[])
{
    setlocale(LC_ALL, "rus");
    // Инициализация переменной n значением 1 в основной нити
    n = 1;

    // Параллельный блок
#pragma omp parallel copyin(n)
    {
        // Каждая параллельная нить выводит значение переменной n
        // После использования директивы copyin, значение n в каждой нити будет равно 1,
        // потому что оно было скопировано из основной нити.
        printf("Значение n: %d\n", n);
    }

    // Программа завершает выполнение
    return 0;
}
